{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cssStringToObject = cssStringToObject;\nexports.cssObjectToString = cssObjectToString;\nexports._constructStyles = _constructStyles;\nexports.computeTextStyles = computeTextStyles;\nexports._getElementClassStyles = _getElementClassStyles;\nexports._getElementCSSClasses = _getElementCSSClasses;\nexports.cssStringToRNStyle = cssStringToRNStyle;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _HTMLUtils = require(\"./HTMLUtils\");\n\nvar _HTMLDefaultStyles = require(\"./HTMLDefaultStyles\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction cssStringToObject(str) {\n  return str.split(\";\").map(function (prop) {\n    return prop.split(\":\");\n  }).reduce(function (acc, prop) {\n    if (prop.length === 2) {\n      acc[prop[0].trim()] = prop[1].trim();\n    }\n\n    return acc;\n  }, {});\n}\n\nfunction cssObjectToString(obj) {\n  var string = \"\";\n  Object.keys(obj).forEach(function (style) {\n    string += style + \":\" + obj[style] + \";\";\n  });\n  return string;\n}\n\nfunction _constructStyles(_ref) {\n  var tagName = _ref.tagName,\n      htmlAttribs = _ref.htmlAttribs,\n      passProps = _ref.passProps,\n      additionalStyles = _ref.additionalStyles,\n      _ref$styleSet = _ref.styleSet,\n      styleSet = _ref$styleSet === void 0 ? \"VIEW\" : _ref$styleSet,\n      baseFontSize = _ref.baseFontSize;\n  var defaultTextStyles = (0, _HTMLDefaultStyles.generateDefaultTextStyles)(baseFontSize);\n  var defaultBlockStyles = (0, _HTMLDefaultStyles.generateDefaultBlockStyles)(baseFontSize);\n  passProps.ignoredStyles.forEach(function (ignoredStyle) {\n    htmlAttribs[ignoredStyle] && delete htmlAttribs[ignoredStyle];\n  });\n  var style = [(styleSet === \"VIEW\" ? defaultBlockStyles : defaultTextStyles)[tagName], passProps.tagsStyles ? passProps.tagsStyles[tagName] : undefined, _getElementClassStyles(htmlAttribs, passProps.classesStyles), htmlAttribs.style ? cssStringToRNStyle(htmlAttribs.style, _HTMLUtils.STYLESETS[styleSet], _objectSpread(_objectSpread({}, passProps), {}, {\n    parentTag: tagName\n  })) : undefined];\n\n  if (additionalStyles) {\n    style = style.concat(!additionalStyles.length ? [additionalStyles] : additionalStyles);\n  }\n\n  return style.filter(function (style) {\n    return style !== undefined;\n  });\n}\n\nfunction computeTextStyles(element, passProps) {\n  var finalStyle = {};\n\n  var parentStyles = _recursivelyComputeParentTextStyles(element, passProps);\n\n  parentStyles.forEach(function (styles) {\n    Object.keys(styles).forEach(function (styleKey) {\n      var styleValue = styles[styleKey];\n\n      if (!finalStyle[styleKey]) {\n        finalStyle[styleKey] = styleValue;\n      }\n    });\n  });\n  return _objectSpread(_objectSpread({}, passProps.baseFontStyle), finalStyle);\n}\n\nfunction _recursivelyComputeParentTextStyles(element, passProps) {\n  var styles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var attribs = element.attribs,\n      name = element.name;\n  var classesStyles = passProps.classesStyles,\n      tagsStyles = passProps.tagsStyles,\n      defaultTextStyles = passProps.defaultTextStyles;\n  var HTMLAttribsStyles = attribs && attribs.style ? cssStringToRNStyle(attribs.style, _HTMLUtils.STYLESETS.TEXT, passProps) : {};\n\n  var classStyles = _getElementClassStyles(attribs, classesStyles);\n\n  var userTagStyles = tagsStyles[name];\n  var defaultTagStyles = defaultTextStyles[name];\n\n  var mergedStyles = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, defaultTagStyles), userTagStyles), classStyles), HTMLAttribsStyles);\n\n  styles.push(mergedStyles);\n\n  if (element.parent) {\n    return _recursivelyComputeParentTextStyles(element.parent, passProps, styles);\n  } else {\n    return styles;\n  }\n}\n\nfunction _getElementClassStyles(htmlAttribs) {\n  var classesStyles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var elementClasses = _getElementCSSClasses(htmlAttribs);\n\n  var styles = {};\n  elementClasses.forEach(function (className) {\n    if (classesStyles[className]) {\n      styles = _objectSpread(_objectSpread({}, styles), classesStyles[className]);\n    }\n  });\n  return styles;\n}\n\nfunction _getElementCSSClasses(htmlAttribs) {\n  if (!htmlAttribs || !htmlAttribs.class) {\n    return [];\n  }\n\n  return htmlAttribs.class.split(\" \");\n}\n\nfunction cssToRNStyle(css, styleset, _ref2) {\n  var emSize = _ref2.emSize,\n      ptSize = _ref2.ptSize,\n      ignoredStyles = _ref2.ignoredStyles,\n      allowedStyles = _ref2.allowedStyles;\n  var styleProps = _HTMLUtils.stylePropTypes[styleset];\n  return Object.keys(css).filter(function (key) {\n    return allowedStyles ? allowedStyles.indexOf(key) !== -1 : true;\n  }).filter(function (key) {\n    return (ignoredStyles || []).indexOf(key) === -1;\n  }).map(function (key) {\n    return [key, css[key]];\n  }).map(function (_ref3) {\n    var _ref4 = (0, _slicedToArray2.default)(_ref3, 2),\n        key = _ref4[0],\n        value = _ref4[1];\n\n    return [key.split(\"-\").map(function (item, index) {\n      return index === 0 ? item : item[0].toUpperCase() + item.substr(1);\n    }).join(\"\"), value];\n  }).map(function (_ref5) {\n    var _ref6 = (0, _slicedToArray2.default)(_ref5, 2),\n        key = _ref6[0],\n        value = _ref6[1];\n\n    if (styleProps.indexOf(key) === -1) {\n      return undefined;\n    }\n\n    if (typeof value === \"string\") {\n      value = value.replace(/\\s*!\\s*important/, \"\");\n\n      if (key === \"display\" && [\"flex\", \"none\"].indexOf(value) === -1) {\n        return [key, \"flex\"];\n      }\n\n      if (key === \"textAlign\") {\n        if ([\"left\", \"right\", \"justify\", \"auto\", \"center\"].indexOf(value) !== -1) {\n          return [key, value];\n        }\n\n        if (value === \"start\") {\n          return [key, \"left\"];\n        }\n\n        if (value === \"end\") {\n          return [key, \"right\"];\n        }\n\n        return undefined;\n      }\n\n      if (value.replace(/[-_]/g, \"\").search(/\\binherit\\b|\\bnormal\\b|\\bnone\\b|(calc|var)\\(.*\\)/) !== -1) {\n        return undefined;\n      }\n\n      if (value.search(/[\\d.]+%/) !== -1 && _HTMLUtils.PERC_SUPPORTED_STYLES.indexOf(key) !== -1) {\n        return [key, value];\n      }\n\n      if (value.search(/[\\d.]+em/) !== -1) {\n        var pxSize = parseFloat(value.replace(\"em\", \"\")) * emSize;\n        return [key, pxSize];\n      }\n\n      if (value.search(/[\\d.]+pt/) !== -1) {\n        var _pxSize = parseFloat(value.replace(\"pt\", \"\")) * ptSize;\n\n        return [key, _pxSize];\n      }\n\n      var numericValue = parseFloat(value.replace(\"px\", \"\"));\n\n      if (key !== \"fontWeight\" && !isNaN(numericValue)) {\n        if (styleProps.indexOf(key) !== -1) {\n          return [key, numericValue];\n        }\n      }\n\n      if (key === \"fontSize\") {\n        return mapAbsoluteFontSize(key, value);\n      }\n    }\n\n    return [key, value];\n  }).filter(function (prop) {\n    return prop !== undefined;\n  }).reduce(function (acc, _ref7) {\n    var _ref8 = (0, _slicedToArray2.default)(_ref7, 2),\n        key = _ref8[0],\n        value = _ref8[1];\n\n    acc[key] = value;\n    return acc;\n  }, {});\n}\n\nfunction mapAbsoluteFontSize(key, value) {\n  var fontSize = value;\n\n  if (_HTMLUtils.ABSOLUTE_FONT_SIZE.hasOwnProperty(value)) {\n    fontSize = _HTMLUtils.ABSOLUTE_FONT_SIZE[value];\n  }\n\n  return [key, fontSize];\n}\n\nfunction cssStringToRNStyle(str) {\n  var styleset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _HTMLUtils.STYLESETS.TEXT;\n  var options = arguments.length > 2 ? arguments[2] : undefined;\n  return cssToRNStyle(cssStringToObject(str), styleset, options);\n}","map":{"version":3,"sources":["C:/Users/mysiew/Documents/eCommerce/codecanyon-xPJMYS8x-react-native-delivery-solution-with-advance-website-and-cms/SourceCode/vesend-consumer-app-master/node_modules/react-native-render-html/src/HTMLStyles.js"],"names":["cssStringToObject","str","split","map","prop","reduce","acc","length","trim","cssObjectToString","obj","string","Object","keys","forEach","style","_constructStyles","tagName","htmlAttribs","passProps","additionalStyles","styleSet","baseFontSize","defaultTextStyles","defaultBlockStyles","ignoredStyles","ignoredStyle","tagsStyles","undefined","_getElementClassStyles","classesStyles","cssStringToRNStyle","STYLESETS","parentTag","concat","filter","computeTextStyles","element","finalStyle","parentStyles","_recursivelyComputeParentTextStyles","styles","styleKey","styleValue","baseFontStyle","attribs","name","HTMLAttribsStyles","TEXT","classStyles","userTagStyles","defaultTagStyles","mergedStyles","push","parent","elementClasses","_getElementCSSClasses","className","class","cssToRNStyle","css","styleset","emSize","ptSize","allowedStyles","styleProps","stylePropTypes","key","indexOf","value","item","index","toUpperCase","substr","join","replace","search","PERC_SUPPORTED_STYLES","pxSize","parseFloat","numericValue","isNaN","mapAbsoluteFontSize","fontSize","ABSOLUTE_FONT_SIZE","hasOwnProperty","options"],"mappings":"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","sourcesContent":["import {\n  PERC_SUPPORTED_STYLES,\n  STYLESETS,\n  ABSOLUTE_FONT_SIZE,\n  stylePropTypes,\n} from \"./HTMLUtils\";\nimport {\n  generateDefaultBlockStyles,\n  generateDefaultTextStyles,\n} from \"./HTMLDefaultStyles\";\n\n/**\n * Converts a html style string to an object\n * @param str: the style string\n * @return the style as an obect\n */\nexport function cssStringToObject(str) {\n  return str\n    .split(\";\")\n    .map((prop) => prop.split(\":\"))\n    .reduce((acc, prop) => {\n      if (prop.length === 2) {\n        acc[prop[0].trim()] = prop[1].trim();\n      }\n      return acc;\n    }, {});\n}\n\nexport function cssObjectToString(obj) {\n  let string = \"\";\n  Object.keys(obj).forEach((style) => {\n    string += `${style}:${obj[style]};`;\n  });\n  return string;\n}\n\n/**\n * Helper that composes styles with the default style for a tag, the \"style\" attribute and\n * any given addiitional style. Checks everything against the style sets of views, images,\n * or texts with prop-types.\n * @export\n * @param {any} { tagName, htmlAttribs, passProps, additionalStyles, styleSet = 'VIEW' }\n * @returns {object}\n */\nexport function _constructStyles({\n  tagName,\n  htmlAttribs,\n  passProps,\n  additionalStyles,\n  styleSet = \"VIEW\",\n  baseFontSize,\n}) {\n  let defaultTextStyles = generateDefaultTextStyles(baseFontSize);\n  let defaultBlockStyles = generateDefaultBlockStyles(baseFontSize);\n\n  passProps.ignoredStyles.forEach((ignoredStyle) => {\n    htmlAttribs[ignoredStyle] && delete htmlAttribs[ignoredStyle];\n  });\n\n  let style = [\n    (styleSet === \"VIEW\" ? defaultBlockStyles : defaultTextStyles)[tagName],\n    passProps.tagsStyles ? passProps.tagsStyles[tagName] : undefined,\n    _getElementClassStyles(htmlAttribs, passProps.classesStyles),\n    htmlAttribs.style\n      ? cssStringToRNStyle(htmlAttribs.style, STYLESETS[styleSet], {\n          ...passProps,\n          parentTag: tagName,\n        })\n      : undefined,\n  ];\n\n  if (additionalStyles) {\n    style = style.concat(\n      !additionalStyles.length ? [additionalStyles] : additionalStyles\n    );\n  }\n\n  return style.filter((style) => style !== undefined);\n}\n\n/**\n * Computes the styles of a text node\n * @export\n * @param {any} element parsed DOM node of text\n * @param {any} passProps set of props from the HTML component\n * @returns {object} react-native styles\n */\nexport function computeTextStyles(element, passProps) {\n  let finalStyle = {};\n\n  // Construct an array with the styles of each level of the text node, ie :\n  // [element, parent1, parent2, parent3...]\n  const parentStyles = _recursivelyComputeParentTextStyles(element, passProps);\n\n  // Only merge the keys that aren't yet applied to the final object. ie:\n  // if fontSize is already set in the first iteration, ignore the fontSize that\n  // we got from the 3rd iteration because of a class for instance, hence\n  // respecting the proper style inheritance\n  parentStyles.forEach((styles) => {\n    Object.keys(styles).forEach((styleKey) => {\n      const styleValue = styles[styleKey];\n      if (!finalStyle[styleKey]) {\n        finalStyle[styleKey] = styleValue;\n      }\n    });\n  });\n\n  // Finally, try to add the baseFontStyle values to add pontentially missing\n  // styles to each text node\n  return { ...passProps.baseFontStyle, ...finalStyle };\n}\n\nfunction _recursivelyComputeParentTextStyles(element, passProps, styles = []) {\n  const { attribs, name } = element;\n  const { classesStyles, tagsStyles, defaultTextStyles } = passProps;\n\n  // Construct every style for this node\n  const HTMLAttribsStyles =\n    attribs && attribs.style\n      ? cssStringToRNStyle(attribs.style, STYLESETS.TEXT, passProps)\n      : {};\n  const classStyles = _getElementClassStyles(attribs, classesStyles);\n  const userTagStyles = tagsStyles[name];\n  const defaultTagStyles = defaultTextStyles[name];\n\n  // Merge those according to their priority level\n  const mergedStyles = {\n    ...defaultTagStyles,\n    ...userTagStyles,\n    ...classStyles,\n    ...HTMLAttribsStyles,\n  };\n\n  styles.push(mergedStyles);\n\n  if (element.parent) {\n    // Keep looping recursively if this node has parents\n    return _recursivelyComputeParentTextStyles(\n      element.parent,\n      passProps,\n      styles\n    );\n  } else {\n    return styles;\n  }\n}\n\n/**\n * Creates a set of style from an array of classes asosciated to a node.\n * @export\n * @param {any} htmlAttribs\n * @param {any} [classesStyles={}]\n * @returns {object}\n */\nexport function _getElementClassStyles(htmlAttribs, classesStyles = {}) {\n  const elementClasses = _getElementCSSClasses(htmlAttribs);\n  let styles = {};\n  elementClasses.forEach((className) => {\n    if (classesStyles[className]) {\n      styles = { ...styles, ...classesStyles[className] };\n    }\n  });\n  return styles;\n}\n\n/**\n * Simple helper that returns an array of classes of a node.\n * @export\n * @param {any} htmlAttribs\n * @returns {array}\n */\nexport function _getElementCSSClasses(htmlAttribs) {\n  if (!htmlAttribs || !htmlAttribs.class) {\n    return [];\n  }\n  return htmlAttribs.class.split(\" \");\n}\n\n/**\n * Converts a html style to its equavalent react native style\n * @param {object} css: object of key value css strings\n * @param {string} styleset: the styleset to convert the styles against\n * @param {object} { parentTag, emSize, ignoredStyles }\n * @returns {object}\n */\nfunction cssToRNStyle(\n  css,\n  styleset,\n  { emSize, ptSize, ignoredStyles, allowedStyles }\n) {\n  const styleProps = stylePropTypes[styleset];\n  return Object.keys(css)\n    .filter((key) => (allowedStyles ? allowedStyles.indexOf(key) !== -1 : true))\n    .filter((key) => (ignoredStyles || []).indexOf(key) === -1)\n    .map((key) => [key, css[key]])\n    .map(([key, value]) => {\n      // Key convert\n      return [\n        key\n          .split(\"-\")\n          .map((item, index) =>\n            index === 0 ? item : item[0].toUpperCase() + item.substr(1)\n          )\n          .join(\"\"),\n        value,\n      ];\n    })\n    .map(([key, value]) => {\n      if (styleProps.indexOf(key) === -1) {\n        return undefined;\n      }\n      if (typeof value === \"string\") {\n        value = value.replace(/\\s*!\\s*important/, \"\");\n        if (key === \"display\" && [\"flex\", \"none\"].indexOf(value) === -1) {\n          return [key, \"flex\"];\n        }\n        if (key === \"textAlign\") {\n          if (\n            [\"left\", \"right\", \"justify\", \"auto\", \"center\"].indexOf(value) !== -1\n          ) {\n            return [key, value];\n          }\n          if (value === \"start\") {\n            return [key, \"left\"];\n          }\n          if (value === \"end\") {\n            return [key, \"right\"];\n          }\n          return undefined;\n        }\n        if (\n          value\n            .replace(/[-_]/g, \"\")\n            .search(/\\binherit\\b|\\bnormal\\b|\\bnone\\b|(calc|var)\\(.*\\)/) !== -1\n        ) {\n          return undefined;\n        }\n        // See if we can use the percentage directly\n        if (\n          value.search(/[\\d.]+%/) !== -1 &&\n          PERC_SUPPORTED_STYLES.indexOf(key) !== -1\n        ) {\n          return [key, value];\n        }\n        if (value.search(/[\\d.]+em/) !== -1) {\n          const pxSize = parseFloat(value.replace(\"em\", \"\")) * emSize;\n          return [key, pxSize];\n        }\n        if (value.search(/[\\d.]+pt/) !== -1) {\n          const pxSize = parseFloat(value.replace(\"pt\", \"\")) * ptSize;\n          return [key, pxSize];\n        }\n        // See if we can convert a 20px to a 20 automagically\n        const numericValue = parseFloat(value.replace(\"px\", \"\"));\n        if (key !== \"fontWeight\" && !isNaN(numericValue)) {\n          if (styleProps.indexOf(key) !== -1) {\n            return [key, numericValue];\n          }\n        }\n        if (key === \"fontSize\") {\n          return mapAbsoluteFontSize(key, value);\n        }\n      }\n      return [key, value];\n    })\n    .filter((prop) => prop !== undefined)\n    .reduce((acc, [key, value]) => {\n      acc[key] = value;\n      return acc;\n    }, {});\n}\n\n/**\n * @param {string} key: the key of style\n * @param {string} value: the value of style\n * @return {array}\n */\nfunction mapAbsoluteFontSize(key, value) {\n  let fontSize = value;\n  if (ABSOLUTE_FONT_SIZE.hasOwnProperty(value)) {\n    fontSize = ABSOLUTE_FONT_SIZE[value];\n  }\n  return [key, fontSize];\n}\n\n/**\n * @param str: the css style string\n * @param styleset=STYLESETS.TEXT: the styleset to convert the styles against\n * @return a react native style object\n */\nexport function cssStringToRNStyle(str, styleset = STYLESETS.TEXT, options) {\n  return cssToRNStyle(cssStringToObject(str), styleset, options);\n}\n"]},"metadata":{},"sourceType":"script"}